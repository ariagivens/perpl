-------- Syntax guide --------

-- This is a single line comment.

{-
This is a multi-line comment.
It can appear just about anywhere,
even in the middle of a line of code.
-}

-- You can define datatypes like this:
data Bool = False | True;

data String = Nil | Cons Bool String;

data State = q0 | q1 | q2;

-- Unfortunately we need to state types at def and also in lambdas
define not : Bool -> Bool =
  \ b : Bool. case b of False -> True | True -> False;

define and : Bool -> Bool -> Bool =
  \ a : Bool, b : Bool. case a of
    | False -> False
    | True -> b;

define iff : Bool -> Bool -> Bool =
  \ a : Bool, b : Bool. case a of
    | False -> not b
    | True -> b;


define string_eq : String -> String -> Bool = \ w1 : String. \ w2 : String.
  case w1 of
    | Nil -> (case w2 of Nil -> True | Cons a w' -> False)
    | Cons b1 w1' -> (case w2 of Nil -> True | Cons b2 w2' -> and (iff b1 b2) (string_eq w1' w2'));

  -- Note the closing semicolon ----------------------------------------^

-- You can declare external distributions like this:
extern transition : State -> Bool * State;
extern accept : State -> Bool;

define gen : State -> String =
  \ q : State. case accept q of
    | True -> Nil
    | False -> (let (a, r) = transition q in Cons a (gen r));

define products : Bool * State -> Bool & State -> Bool =
  \ prod : Bool * State, amp : Bool & State.
    -- With *-types, you can access both parts like this:
    let (b, q) = prod in
    -- But with &-types, you can only access ONE part:
    let b' = amp.1 in
    -- or: let q' = amp.2 in ...
    -- You CANNOT do
    -- let <b', q'> = amp in ...
    -- Nor can you use both amp.1 and amp.2
    
    -- To make a *-product:
    let prod' = (False, q1) in
    -- To make a &-product:
    let amp' = <False, q1> in
    True;


define samples : (Bool -> Bool -> Bool -> Bool -> Bool) -> Bool =
  \ f : Bool -> Bool -> Bool -> Bool -> Bool. f
    (sample fail : Bool)     -- p(False) = 0,   p(True) = 0   (all members get p = 0)
    (sample amb : Bool)      -- p(False) = 1,   p(True) = 1   (all members get p = 1)
    (sample uniform : Bool) -- p(False) = 0.5, p(True) = 0.5 (split p between all members)
    (amb False True False);   -- p(False) = 2,   p(True) = 1   (all branches get p = 1)

-- You must then end the program with something to run, like
string_eq (gen q0) (gen q0)
